var documenterSearchIndex = {"docs":
[{"location":"manual/#CDCP.jl-Documentation","page":"Manual","title":"CDCP.jl Documentation","text":"","category":"section"},{"location":"manual/#CDCP.CDCP","page":"Manual","title":"CDCP.CDCP","text":"Solve CDCPs. Main functions provided are solve!, solve, and policy. See here for more.\n\n\n\n\n\n","category":"module"},{"location":"manual/#CDCP.naive!-Tuple{AbstractVector{Bool}}","page":"Manual","title":"CDCP.naive!","text":"naive!(J::AbstractVector{Bool}; obj)\n\nSolve in-place a combinatorial discrete choice problem with simple brute force. (Generally used for testing or time-trial exercises.) The solver expectes a pre-allocated Boolean vector J and objective function obj(J).\n\nSee also: naive, solve!, policy\n\n\n\n\n\n","category":"method"},{"location":"manual/#CDCP.naive-Tuple{Integer}","page":"Manual","title":"CDCP.naive","text":"naive(C::Integer; obj)\n\nSolve a combinatorial discrete choice problem over C choices with simple brute force. (Generally used for testing or time-trial exercises.) The solver an objective function π(J).\n\nSee also: naive!, solve!, policy\n\n\n\n\n\n","category":"method"},{"location":"manual/#CDCP.policy-Tuple{Integer}","page":"Manual","title":"CDCP.policy","text":"policy(C::Integer; scdca::Bool, obj, equalise_obj, [D_j_obj, zero_D_j_obj])\n\nFind the policy function for a combinatorial discrete choice problem over C choices and one dimension of heterogeneity with SCD-C from above if scdca is true (otherwise, from below) and SCD-T. The solver uses the objective function obj(J, z), which must accept as argument a Boolean vector with length C and the heterogeneous component z and the equalise_obj((J1, J2), l, r) function, which identifies the z where the agent is indifferent between the pair (J1, J2). The routine provides the interval [l, r] along which this search is performed; if the marginal type is not in the interval, it is sufficient to return nothing.\n\nThe solver can optionally take D_j_obj(j, J, z) and zero_D_j_obj(j, J, l, r), user-supplied functions. The first is the marginal value function, while the second identifies the z where the marginal value of item j to set J is zero. For the second, the solver provides the interval [l, r] within which this marginal type is located. It is sufficient to return nothing is the marginal type is not within the interval. If not provided, the solver automatically constructs these using the equalise_obj function.\n\nSee also: solve!, solve\n\n\n\n\n\n","category":"method"},{"location":"manual/#CDCP.solve!-Tuple{Any}","page":"Manual","title":"CDCP.solve!","text":"solve!((sub, sup, aux); scdca::Bool, obj, [D_j_obj; containers])\n\nSolve in-place a combinatorial discrete choice problem with SCD-C from above if scdca is true (otherwise, from below). The solver uses the preallocated Boolean vectors (sub, sup, aux) as well as the objective function obj(J). The objective function obj must accept as argument a Boolean vector with length corresponding to the number of items in the problem.\n\nThe solver can optionally take D_j_obj(j, J), a user-supplied marginal value function; otherwise it will construct one automatically given π. It may also optionally take preallocated containers = (working, converged), where working and converged are both Vectors with element type matching (sub, sup, aux). These are used for the branching step and will be automatically allocated if not supplied.\n\nSee also: solve, policy\n\n\n\n\n\n","category":"method"},{"location":"manual/#CDCP.solve-Tuple{Integer}","page":"Manual","title":"CDCP.solve","text":"solve(C::Integer; scdca::Bool, obj, [D_j_obj; containers])\n\nSolve a combinatorial discrete choice problem over C choices with SCD-C from above if scdca is true (otherwise, from below). The solver uses the objective function obj(J) which must accept as argument a Boolean vector with length corresponding to the number of items in the problem.\n\nThe solver can optionally take D_j_obj(j, J), a user-supplied marginal value function; otherwise it will construct one automatically given obj. It may also optionally take preallocated containers = (working, converged), where working and converged are both Vectors with element type matching (sub, sup, aux). These are used for the branching step and will be automatically allocated if not supplied.\n\nSee also: solve!, policy\n\n\n\n\n\n","category":"method"},{"location":"#CDCP","page":"Introduction","title":"CDCP","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A Julia package to solve combinatorial discrete choice problems, either for single agents or over a single dimension of heterogeneity.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"From command line:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia -e 'import Pkg; Pkg.add(url=\"https://github.com/rowanxshi/CDCP.jl#main\")'","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"From within Julia:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(url=\"https://github.com/rowanxshi/CDCP.jl#main\")","category":"page"},{"location":"#Key-functions","page":"Introduction","title":"Key functions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package provides solve!, solve, and policy.","category":"page"},{"location":"#Single-agent-problems","page":"Introduction","title":"Single agent problems","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Either solve! or solve can handle single agent problems. The first solves the problem inplace, so it should be provided with three pre-allocated Boolean vectors (sub, sup, aux), the objective function obj, and whether the problem satisfies SCD-C from above.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"solve!((sub, sup, aux); scdca::Bool, obj, [D_j_obj; containers])","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The solver expects the objective function obj(J) to accept a Boolean vector like sub.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There are two optional arguments: the marginal value function D_j_obj(j, J) and containers. The marginal value function should accept an index j and a Boolean vector J, computing the marginal value of item j to the set J. If the marginal value function is omitted, the solver automatically generates one using the provided objective function obj.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The containers = (working, converged) can be preallocated and passed to the solver. Both working and converged are Vectors holding elements like (sub, sup, aux). These are used for the branching step and will be automatically allocated if not supplied.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"ExamplesSuppose we have the objective function obj(J) and marginal value function D_j_obj(j, J:) already defined and that the CDCP is over C items. We can preallocate everything, then call the solver as follows.sub = falses(C)\nsup = trues(C)\naux = falses(C)\nworking = [(sub, sup, aux); ]\nconverged = similar(working)If the objective obeys SCD-C from above:solve!((sub, sup, aux); scdca = true, obj, D_j_obj, containers = (working, converged)) If the objective obeys SCD-C from below:solve!((sub, sup, aux); scdca = false, obj, D_j_obj, containers = (working, converged)) We could equally call the solver omitting the preallocated containers, the marginal value function, or both:solve!((sub, sup, aux); scdca = true, obj, D_j_obj)\nsolve!((sub, sup, aux); scdca = true, obj, containers = (working, converged)) \nsolve!((sub, sup, aux); scdca = true, obj)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pre-allocating is helpful if the problem will be solved many times because it avoids the solver allocating the vectors each time.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"solve(C::Integer; scdca::Bool, obj, [D_j_obj; containers])","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Non-inplace versions, where C is the number of items in the CDCP. (C need not be specified for the inplace caller, since it can be inferred from the length of the Boolean vectors.) They are otherwise identical in usage to the inplace versions.","category":"page"},{"location":"#Policy-function","page":"Introduction","title":"Policy function","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package provides policy to identify the policy function for problems over a single dimension of heterogeneity (which we call productivity from here).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"policy(C::Integer; scdca::Bool, obj, equalise_obj, [D_j_obj, zero_D_j_obj])","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The solver now expects the objective function obj(J, z) to accept a Boolean vector J and a real number z describing productivity. It also requires a function equalise_obj((J1, J2), l, r), which takes a pair of Boolean vectors (J1, J2) and returns the productivity of an agent indifferent between the two strategies. The solver provides the interval [l, r] within which the search should be performed; if the marginal type is not in the interval, it is sufficient to return nothing.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Similarly to the single-agent solver, the marginal value function D_j_obj is optional; it is automatically generated using the obj function if omitted.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A function zero_D_j_obj(j, J, l, r) may optionally be provided, which accepts an index j, Boolean vector J, and interval endpoints l and r. It should return the productivity at which the marginal value of j to set J is zero. The solver provides the interval [l, r] within which this marginal type is located. If the function is omitted, the solver automatically constructs one using the equalise_obj function.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The policy function will be returned as a series of cutoff productivities and the optimal decision sets for all types within each interval.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"ExamplesSuppose we have our three functions obj(J, z), zero_D_j_obj(j, J, l, r) and equalise_obj((J1, J2), l, r) defined. The CDCP is over C = 3 items. We can call the solver as follows.If the objective obeys SCD-C from above:(cutoffs, policies) = policy(3; scdca = true, obj, equalise_obj, zero_D_j_obj)If the objective obeys SCD-C from below(cutoffs, policies) = policy(3; scdca = false, obj, equalise_obj, zero_D_j_obj)We could equally omit the zero_D_j_obj function, letting the solver generate one itself:(cutoffs, policies) = policy(3; scdca = false, obj, equalise_obj)The returned returned cutoffs will be a vector of cutoffs; say cutoffs = [-Inf, 2, 4, 6, Inf]. The returned policies will be a vector of Boolean arrays, say[\n\t[false; false; false];\n\t[false; false; true];\n\t[true; false; true];\n\t[true; true; true];\n]The length of cutoffs will always exceed the length of policies by 1. This result means that for agents with productivity in between (-Inf, 2), the optimal strategy is [false; false; false] –- that is, to select none of the items. The optimal strategy for the next interval given by the cutoffs, (2, 4), is [false; false; true]; and so on.  ","category":"page"}]
}
