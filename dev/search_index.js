var documenterSearchIndex = {"docs":
[{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Main-interface","page":"Manual","title":"Main interface","text":"","category":"section"},{"location":"manual/#CommonSolve.solve-Union{Tuple{Algorithm}, Tuple{Type{Algorithm}, Vararg{Any}}} where Algorithm<:CDCPSolver","page":"Manual","title":"CommonSolve.solve","text":"solve(Algorithm::CDCPSolver, obj, args...; kwargs...) = cdcp::CDCProblem\n\nSolve a combinatorial discrete choice problem with a given solution algorithm that can be SqueezingPolicy, Squeezing or Naive. Results are returned as a CDCProblem.\n\nThe objective function obj should return the value evaluated at a choice vector ℒ with an optional parameter z that is typically a number (e.g. productivity).\n\nobj must have a method of either obj(ℒ) (if no parameter is specified) or obj(ℒ, z) (if a parameter is specified). obj must not restrict the specific type of ℒ but only assume ℒ is a vector with element type being Bool. Specifically, obj must not try to modify the elements in ℒ when it is called. It should only read from ℒ with getindex.\n\nsolve(Squeezing, obj, scdca::Bool; z=nothing)\n\nThe problem should satisfy SCD-C from above if scdca is true and SCD-C from below if scdca is false.\n\nKeywords\n\nz=nothing\n\nsolve(SqueezingPolicy, obj, scdca::Bool, equal_obj, zbounds::Tuple{Z,Z}=(-Inf, Inf); kwargs...)\n\nThe problem should satisfy SCD-C from above if scdca is true and SCD-C from below if scdca is false.\n\nThe function equal_obj should returns the cutoff type z with zleft <= z0 <= zright that is indifferent between two decision sets ℒ1 and ℒ2.\n\nequal_obj can be defined with one of the two following methods:\n\nequal_obj((ℒ1, ℒ2), zleft, zright): where the pair of input choices is accepted as a tuple\nequal_obj(obj1::Objective, obj2::Objective, zleft, zright): where obj1 and obj2 are the same objective function attached with different input vectors obj1.ℒ and obj2.ℒ that correspond to ℒ1 and ℒ2 respectively\n\nzbounds determines the domain of the parameter z, which defaults to (-Inf, Inf).\n\nKeywords\n\nzero_margin=nothing: a function that returns the type z that is indifferent to adding item ℓ to decision set ℒ; it should have the method zero_margin(obj::Objective, ℓ::Int, zleft, zright) with ℒ attached to obj and if not supplied, this function will be generated automatically from equal_obj\npolicy0::Policy=Policy(obj, zbounds): initial policy which on top of which optimisation occurs\nskiprefinement::Bool=false: skip the refinement step that searches resolves intervals for which squeezing doesn't pin down optimal policy\nsinglekw=NamedTuple(): keyword arguments passed to the single-agent solver as a NamedTuple used in the branching stage.\nmaxfcall=1_000_000_000: maximum calls to the objective function\n\nsolve(Naive, obj; kwargs...)\n\nSolve with exhaustion by checking all potential decision sets. This method should be used with extreme caution.\n\nKeywords\n\nz=nothing: the type parameterising the problem\n\n\n\n\n\n","category":"method"},{"location":"manual/#CDCP.CDCProblem","page":"Manual","title":"CDCP.CDCProblem","text":"CDCProblem{M<:CDCPSolver, O<:Objective, T, F<:AbstractFloat}\n\nResults from solving a combinatorial discrete choice problem with solve. When a solution is attained, it can be retrieved from the field x.\n\nFields\n\nsolver::CDCPSolver\nobj::[Objective]: the objective function\nx: the solution, once solved\nvalue: the maximum value found by the solver\nstate::SolverState\n\n\n\n\n\n","category":"type"},{"location":"manual/#CDCP.SolverState","page":"Manual","title":"CDCP.SolverState","text":"SolverState::Int8\n\nAn Enum type with values:\n\ninprogress\nsuccess\nmaxfcall_reached\n\nSee also solve, CDCProblem.\n\n\n\n\n\n","category":"type"},{"location":"manual/#Returned-solutions-types","page":"Manual","title":"Returned solutions types","text":"","category":"section"},{"location":"manual/#CDCP.ItemState","page":"Manual","title":"CDCP.ItemState","text":"ItemState::Int8\n\nAn Enum type describing the state of item ℓ with values:\n\nexcluded: from squeezing, definitely excluded\nincluded: from squeezing, definitely included\naux: checked, but cannot definitively include or exclude based on squeezing\nundetermined: not yet checked\n\nSee also solve, CDCProblem.\n\n\n\n\n\n","category":"type"},{"location":"manual/#CDCP.Policy","page":"Manual","title":"CDCP.Policy","text":"Policy{Z,V<:AbstractVector{ItemState}} <: AbstractVector{IntervalChoice{Z,V}}\n\nPolicy function derived from SqueezingPolicy.\n\nGiven a policy function policy::Policy, the optimal decision set of a type z can be retrieved as expected, i.e. policy(z).\n\nSee also solve, CDCProblem.\n\nFields\n\ncutoffs::Vector{Z}: cutoff types at which optimal decision set switches\nitemstates_s::Vector{V}: a vector of decision sets, so that itemstates_s[k] corresponds to the types above cutoffs[k] and below cutoffs[k+1]\nzright::Z: the \n\n\n\n\n\n","category":"type"},{"location":"compat/#Backwards-compatible-methods","page":"Backwards compatibility","title":"Backwards-compatible methods","text":"","category":"section"},{"location":"compat/#CommonSolve.solve-Tuple{Integer}","page":"Backwards compatibility","title":"CommonSolve.solve","text":"solve(C::Integer; scdca::Bool, obj)\n\nSolve a combinatorial discrete choice problem over C choices with SCD-C from above if scdca is true (otherwise, from below).\n\nThe solver uses the objective function obj(J) which must accept as argument a Boolean vector of length C.\n\nwarning: Warning\nThis method exists only for the sake of backward compatibility. Future use should prefer the interface based on solve(Squeezing, ...).\n\n\n\n\n\n","category":"method"},{"location":"compat/#CommonSolve.solve!-Tuple{Any}","page":"Backwards compatibility","title":"CommonSolve.solve!","text":"solve!((sub, sup, aux); scdca::Bool, obj, restart::Bool=true)\n\nSolve in-place a combinatorial discrete choice problem with SCD-C from above if scdca is true (otherwise, from below). The solver uses the objective function obj(J) and initiates using the Boolean vectors (sub, sup, aux) if restart=false. The objective function obj must accept as argument a Boolean vector with length corresponding to the number of items in the problem.\n\nwarning: Warning\nThis method exists only for the sake of backward compatibility. Future use should prefer the interface based on solve(Squeezing, ...).\n\n\n\n\n\n","category":"method"},{"location":"compat/#CDCP.policy-Tuple{Integer}","page":"Backwards compatibility","title":"CDCP.policy","text":"policy(C::Integer; scdca::Bool, obj, equalise_obj, [zero_D_j_obj])\n\nFind the policy function for a combinatorial discrete choice problem over C choices and one dimension of heterogeneity with SCD-C from above if scdca is true (otherwise, from below) and SCD-T. The solver uses the objective function obj(J, z), which must accept as argument a Boolean vector with length C and the heterogeneous component z and the equalise_obj((J1, J2), l, r) function, which identifies the z where the agent is indifferent between the pair (J1, J2). The routine provides the interval [l, r] along which this search is performed.\n\nThe solver can optionally take zero_D_j_obj(j, J, l, r), a user-supplied function that identifies the z where the marginal value of item j to set J is zero. The solver provides the interval [l, r] within which this marginal type is located. If not provided, the solver automatically constructs these using the equalise_obj function.\n\nwarning: Warning\nThis method exists only for the sake of backward compatibility. Future use should prefer the interface based on solve(SqueezingPolicy, ...).\n\n\n\n\n\n","category":"method"},{"location":"compat/#CDCP.policy!-Tuple{Any, Any, Integer}","page":"Backwards compatibility","title":"CDCP.policy!","text":"policy!((cutoffs, policies), containers0, C::Integer; scdca::Bool, obj, equalise_obj, zero_D_j_obj=zero_D_j(equalise_obj, falses(C)), restart::Bool=true)\n\nThe similar to policy, but the solver initiates with working0 in containers0 = (working0, _, _) if restart=false.\n\nwarning: Warning\nThis method exists only for the sake of backward compatibility. Future use should prefer the interface based on solve(SqueezingPolicy, ...).\n\n\n\n\n\n","category":"method"},{"location":"compat/#CDCP.naive-Tuple{Integer}","page":"Backwards compatibility","title":"CDCP.naive","text":"naive(C::Integer; obj)\n\nSolve a combinatorial discrete choice problem with objective function π(J) over C choices with exhaustion.\n\nwarning: Warning\nThis method exists only for the sake of backward compatibility. Future use should prefer the interface based on solve(Naive, ...).\n\n\n\n\n\n","category":"method"},{"location":"compat/#CDCP.naive!-Tuple{AbstractVector{Bool}}","page":"Backwards compatibility","title":"CDCP.naive!","text":"naive!(J::AbstractVector{Bool}; obj)\n\nSimilar to naive, but accepts a pre-allocated vector J.\n\nwarning: Warning\nThis method exists only for the sake of backward compatibility. Future use should prefer the interface based on solve(Naive, ...).\n\n\n\n\n\n","category":"method"},{"location":"#Combinatorial-Discrete-Choice-Problems","page":"Introduction","title":"Combinatorial Discrete Choice Problems","text":"","category":"section"},{"location":"#CDCP","page":"Introduction","title":"CDCP","text":"Solve combinatorial discrete choice problems as in Arkolakis, Eckert and Shi (2025).\n\nSee also solve, Squeezing, SqueezingPolicy.\n\n\n\n\n\n","category":"module"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"From command line:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia -e 'import Pkg; Pkg.add(url=\"https://github.com/rowanxshi/CDCP.jl#main\")'","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"From within Julia:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(url=\"https://github.com/rowanxshi/CDCP.jl#main\")","category":"page"},{"location":"#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"#Single-agent-problem","page":"Introduction","title":"Single agent problem","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Suppose we have the objective function obj(J) already defined and that the CDCP is over C items. We can call the solver as follows.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"solve(Squeezing, obj, true) # If the objective obeys SCD-C from above\nsolve(Squeezing, obj, false) # If the objective obeys SCD-C from below","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Suppose we have the objective function obj(J, z) already defined for parameter z (e.g. productivity). Then, we can call the solver similarly for type z=5:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"solve(Squeezing, obj, true; z=5) # If the objective obeys SCD-C from above\nsolve(Squeezing, obj, false; z=5) # If the objective obeys SCD-C from below","category":"page"},{"location":"#Policy-function","page":"Introduction","title":"Policy function","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The solver now expects the objective function obj(J, z) to accept a Boolean vector J and a real number z describing type (e.g. productivity). It also requires a function equalise_obj((J1, J2), l, r), which takes a pair of Boolean vectors (J1, J2) and returns the type of an agent indifferent between the two strategies.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Suppose we have our three functions obj(J, z) and equalise_obj((J1, J2), l, r) defined. We can call the solver as follows.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If the objective obeys SCD-C from above:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"solve(SqueezingPolicy, obj, true, equal_obj) # If the objective obeys SCD-C from above\nsolve(SqueezingPolicy, obj, false, equal_obj) # If the objective obeys SCD-C from below","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#Objective-function","page":"Internals","title":"Objective function","text":"","category":"section"},{"location":"internals/#CDCP.Objective","page":"Internals","title":"CDCP.Objective","text":"Objective{F,V <: AbstractVector}\n\nA wrapped objective function for solving a CDCProblem. This facilitates maintaining an internal interface for dealing with objective functions that is independent from user interface.\n\nUsers are not required to construct Objective unless there is a need for fine-grained control.\n\nFields\n\nf::F: objective function\nℒ::V: the decision vector at which to evaluate the objective function\nfcall::Int = 0: the number of times the objective has been called, used to track whether the maximum number of objective calls has been reached (see also CDCProblem)\n\n\n\n\n\n","category":"type"},{"location":"internals/#CDCP.margin","page":"Internals","title":"CDCP.margin","text":"margin(obj::Objective, ℓ::Int, z)\n\nEvaluate the change in obj with optional parameter z when the ℓth item is included or not. This corresponds to the D_j function in earlier implementation.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Solution-methods","page":"Internals","title":"Solution methods","text":"","category":"section"},{"location":"internals/#CDCP.CDCPSolver","page":"Internals","title":"CDCP.CDCPSolver","text":"CDCPSolver\n\nAbstract type for all solution algorithms for a CDCProblem.\n\nSee also Naive, Squeezing, SqueezingPolicy.\n\n\n\n\n\n","category":"type"},{"location":"internals/#CDCP.Naive","page":"Internals","title":"CDCP.Naive","text":"Naive{Z} <: CDCPSolver\n\nA type for solving a CDCProblem with exhaustion.\n\n\n\n\n\n","category":"type"},{"location":"internals/#CDCP.Squeezing","page":"Internals","title":"CDCP.Squeezing","text":"Squeezing{V <: AbstractVector,Z} <: CDCPSolver\n\nA type for solving a CDCProblem with single-agent squeezing.\n\nSee also solve.\n\nFields\n\nscdca::Bool: does the problem obey single crossing differences in choices from above? (if false, then from below is assumed)\nbranching::Vector{V}: container holding branching outcomes\nz: the parameter (e.g. productivity) of the problem\nbranch::Bool = true: whether or not to branch\n\n\n\n\n\n","category":"type"},{"location":"internals/#CDCP.SqueezingPolicy","page":"Internals","title":"CDCP.SqueezingPolicy","text":"SqueezingPolicy{Z,V<:AbstractVector{ItemState},F1,F2,S,O} <: CDCPSolver\n\nA type for solving a CDCProblem with policy function squeezing.\n\nSee also solve.\n\nFields\n\nscdca::Bool\nintervalchoices::Vector{IntervalChoice{Z,V}}\nsqueezing_indices::Vector{Int}\nbranching_indices::Vector{Int}\nzero_margin::F1\nequal_obj::F2\nsinglecdcp::S\nobj2::O\nskiprefinement::Bool\nmaxfcall::Int\n\n\n\n\n\n","category":"type"}]
}
